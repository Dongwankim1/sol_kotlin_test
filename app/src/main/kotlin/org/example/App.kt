/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import org.p2p.solanaj.core.PublicKey
import org.p2p.solanaj.core.Account
import org.p2p.solanaj.programs.TokenProgram
import org.p2p.solanaj.programs.AssociatedTokenProgram
import org.p2p.solanaj.rpc.RpcClient
import org.p2p.solanaj.programs.SystemProgram
import org.p2p.solanaj.core.Transaction
import org.bitcoinj.core.Base58
import java.math.BigInteger


fun main() {
    println("qfqwfqwf")
     val rpcEndpoint = "https://api.devnet.solana.com"
	 val publicKey = "8ixPw2F1J2g724nkYeZtg4fEFrWTRf2Tna965rbwsVoD"
	 val mint = "E3iTukHHrabJ1f3mW8rKRZV6Y4PKMzoLD1HmN8gNGpgt"
	 val secretKey = "digital drink present man hamster leave orbit scorpion tackle cheese chat cabbage"
    val solanaService = SolanaService()
    

    println(solanaService.getBalance(rpcEndpoint,publicKey))

    solanaService.splTokenBalance(rpcEndpoint, secretKey, publicKey, mint)
}


class SolanaService {



    private fun getConnection(rpcEndpoint: String): RpcClient {
        return RpcClient(rpcEndpoint)
    }

    fun testConnection(rpcEndpoint: String): String {
        val client = getConnection(rpcEndpoint)
        return try {
            val version = client.api.getVersion() // Test API call
            "Connected to Solana RPC: $version"
        } catch (e: Exception) {
            "Failed to connect to Solana RPC: ${e.message}"
        }
    }

    fun getBalance(rpcEndpoint: String, publicKey: String): Double {
        println("getBalance")
        val connection = getConnection(rpcEndpoint)
        return try {
            val lamports = connection.api.getBalance(PublicKey(publicKey))
            lamports.toDouble() / LAMPORTS_PER_SOL
        } catch (e: Exception) {
            println("Error fetching balance: ${e.message}")
            0.0
        }
    }

    fun splTokenBalance(
        rpcEndpoint: String,
        secretKey: String,
        publicKey: String,
        mint: String
    ): Double {
        println("splTokenBalance")
        val connection = getConnection(rpcEndpoint)
        println("mint = "+mint)
        println("mint true = "+isValidBase58(mint))
        
        val mintAddress = PublicKey(mint)
        println("mintByteArray = "+mintAddress);
        // val secretByteArray = Base58.encode(secretKey.toByteArray());
        val secretKeypair = Account(secretKey.toByteArray())
        println("splTokenBalance2")
        // Select the correct program ID and lamports conversion based on the environment
        return try {
            // Find or create the associated token account
            val tokenAccount = getOrCreateAssociatedTokenAccount(
                connection,
                secretKeypair,
                mintAddress,
                PublicKey(publicKey),
                false,
                "comfirmd",
                TokenProgram.PROGRAM_ID
            )
            println("tokenAccount  " + tokenAccount)
            0.0
        } catch (e: Exception) {
            println("Error fetching SPL token balance: ${e.message}")
            0.0
        }
        //     // Get the token balance
        //     val balanceResponse = connection.api.getTokenAccountBalance(tokenAccount.publicKey)
        //     val tokenAmount = balanceResponse?.value?.uiAmount ?: 0.0

        //     tokenAmount / lamportsSol
        // } catch (e: Exception) {
        //     println("Error fetching SPL token balance: ${e.message}")
        //     0.0
        // }
    }

    fun getOrCreateAssociatedTokenAccount(
        connection: RpcClient,
        payer: Account,
        mint: PublicKey,
        owner: PublicKey,
        allowOwnerOffCurve: Boolean = false,
        commitment: String = "confirmed",
        programId: PublicKey = TokenProgram.PROGRAM_ID
    ): Pair<PublicKey, BigInteger> {
        // Calculate the associated token account (ATA) address
        val associatedTokenAddress = PublicKey.findProgramAddress(
            listOf(
                owner.toByteArray(),
                TokenProgram.PROGRAM_ID.toByteArray(),
                mint.toByteArray()
            ),
            TokenProgram.PROGRAM_ID
        )
        println("associatedTokenAddress : "+associatedTokenAddress.address)
        // Check if the ATA exists
        val accountInfo = connection.api.getAccountInfo(associatedTokenAddress.address)
        println("accountInfo = "+accountInfo);
        if (accountInfo != null) {
            // Fetch balance if ATA exists
            val tokenBalance = connection.api.getTokenAccountBalance(associatedTokenAddress.address)
            // return Pair(associatedTokenAddress?.address, tokenBalance?.amount)
            println("datata");
        }

        // If ATA doesn't exist, create it
        val transaction = Transaction()
        val rentExemption = connection.api.getMinimumBalanceForRentExemption(165)

        transaction.addInstruction(
            SystemProgram.createAccount(
                payer.publicKey,
                associatedTokenAddress.address,
                rentExemption,
                165,
                programId
            )
        )

        transaction.addInstruction(
            TokenProgram.initializeAccount(
                associatedTokenAddress.address,
                mint,
                owner
            )
        )

        // connection.api.sendTransaction(transaction, listOf(payer))
        print("associatedTokenAddress.address" + associatedTokenAddress.address)
        return Pair(associatedTokenAddress.address, BigInteger.ZERO)
    }

    companion object {
        private const val LAMPORTS_PER_SOL = 1_000_000_000 // 1 SOL = 1 billion lamports
    }

    fun isValidBase58(input: String): Boolean {
        val base58Pattern = Regex("^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+\$")
        return base58Pattern.matches(input)
    }
    
}